#-----------------------------------------------------#
# Please don't delete or modify this comment.
# DEVLIB:advanced_logging_for_live_event_monitoring 0ed965d6 dc2fb7d6d6d15d79 997e1535da2b121b
# {"log":true,"tablename":"lem_logging","loggingDictName":"lem_logging","loggingDictDef":{"enabled":"0"},"logConfigName":"LEMBigQuery"}
#-----------------------------------------------------#
# For logging
#
# We use the following headers to stash information:
#   * log-client
#   * log-origin
#   * log-request
#   * log-response
#   * log-timing
#


sub solution_advanced_logging_for_live_event_monitoring_recv {
set client.geo.ip_override = req.http.fastly-client-ip;
set req.http.log-request:host = req.http.host;
set req.http.log-request:method = req.method;
set req.http.log-request:url = req.url;
}


sub solution_advanced_logging_for_live_event_monitoring_miss {
set req.http.log-timing:misspass = time.elapsed.usec;
if (req.backend.is_origin) {
  unset bereq.http.log-request;
}
}
sub solution_advanced_logging_for_live_event_monitoring_pass {
set req.http.log-timing:misspass = time.elapsed.usec;
if (req.backend.is_origin) {
  unset bereq.http.log-request;
}
}
sub solution_advanced_logging_for_live_event_monitoring_fetch {
set beresp.http.log-timing:fetch = time.elapsed.usec;
set beresp.http.log-timing:misspass = req.http.log-timing:misspass;
set beresp.http.log-timing:do_stream = beresp.do_stream;

set beresp.http.log-origin:ip = beresp.backend.ip;
set beresp.http.log-origin:port = beresp.backend.port;
set beresp.http.log-origin:name = regsub(beresp.backend.name, "^.+--", "");
set beresp.http.log-origin:status = beresp.status;
set beresp.http.log-origin:reason = beresp.response;

set beresp.http.log-origin:method = bereq.method;
set beresp.http.log-origin:url = bereq.url;
set beresp.http.log-origin:host = bereq.http.host;

if (req.backend.is_origin) {
  set beresp.http.log-origin:shield = server.datacenter;
}
}
sub solution_advanced_logging_for_live_event_monitoring_deliver {
set req.http.log-timing:deliver = time.elapsed.usec;
set req.http.log-timing:fetch = resp.http.log-timing:fetch;
set req.http.log-timing:misspass = resp.http.log-timing:misspass;
set req.http.log-timing:do_stream = resp.http.log-timing:do_stream;
unset resp.http.log-timing;

set req.http.log-origin = resp.http.log-origin;

if (fastly.ff.visits_this_service == 0) {
  unset resp.http.log-origin;
}
}
sub solution_advanced_logging_for_live_event_monitoring_error {
# req.backend.is_origin is not available in vcl_error
if (!req.backend.is_shield) {
  set obj.http.log-origin:shield = server.datacenter;
}
}
sub solution_advanced_logging_for_live_event_monitoring_log {
set req.http.log-timing:log = time.elapsed.usec;

declare local var.origin_ttfb FLOAT;
declare local var.origin_ttlb FLOAT;
declare local var.enabled STRING; 

if (fastly_info.state ~ "^(MISS|PASS)") {
# origin_ttfb = fetch - misspass
set var.origin_ttfb = std.atof(req.http.log-timing:fetch);
set var.origin_ttfb -= std.atof(req.http.log-timing:misspass);

if (req.http.log-timing:do_stream == "1") {
    # origin_ttlb = log - misspass
    # (and some clustering)
    set var.origin_ttlb = std.atof(req.http.log-timing:log);
    set var.origin_ttlb -= std.atof(req.http.log-timing:misspass);
} else {
    # origin_ttlb = deliver - misspass
    # (and some clustering)
    set var.origin_ttlb = std.atof(req.http.log-timing:deliver);
    set var.origin_ttlb -= std.atof(req.http.log-timing:misspass);
}
}

set var.origin_ttfb /= 1000;
set var.origin_ttlb /= 1000;

# ttfb = time.to_first_byte (just before deliver)
declare local var.response_ttfb FLOAT;
set var.response_ttfb = time.to_first_byte;
set var.response_ttfb *= 1000;

# ttlb = log
declare local var.response_ttlb FLOAT;
set var.response_ttlb = std.atof(req.http.log-timing:log);
set var.response_ttlb /= 1000;

declare local var.client_tcpi_rtt INTEGER;
set var.client_tcpi_rtt = client.socket.tcpi_rtt;
set var.client_tcpi_rtt /= 1000;

# Only log origin/shield info if we actually went to origin/shield
if (fastly_info.state !~ "^(MISS|PASS)") {
  unset req.http.log-origin:host;
  unset req.http.log-origin:ip;
  unset req.http.log-origin:method;
  unset req.http.log-origin:name;
  unset req.http.log-origin:port;
  unset req.http.log-origin:reason;
  unset req.http.log-origin:shield;
  unset req.http.log-origin:status;
  unset req.http.log-origin:url;
  set var.origin_ttfb = math.NAN;
  set var.origin_ttlb = math.NAN;
}

set req.http.log-client:tcpi_rtt = var.client_tcpi_rtt;
set req.http.log-origin:ttfb = var.origin_ttfb;
set req.http.log-origin:ttlb = var.origin_ttlb;
set req.http.log-response:ttfb = var.response_ttfb;
set req.http.log-response:ttlb = var.response_ttlb; 

set var.enabled = table.lookup(lem_logging,"enabled", "0");

if ( var.enabled == true) {
    log {"syslog "} req.service_id {" LEMBigQuery :: "} {"{ "timestamp":""} strftime({"%Y-%m-%dT%H:%M:%S"}, time.start) "." time.start.usec_frac {"Z", "client_as_number":"} client.as.number {", "client_city":""} client.geo.city {"", "client_congestion_algorithm":""} client.socket.congestion_algorithm {"", "client_country_code":""} client.geo.country_code3 {"", "client_cwnd":"} client.socket.cwnd {", "client_delivery_rate":"} client.socket.tcpi_delivery_rate {", "client_ip":""} req.http.fastly-client-ip {"", "client_latitude":"} if(client.geo.latitude == 999.9, "null", client.geo.latitude) {", "client_longitude":"} if(client.geo.longitude == 999.9, "null", client.geo.longitude) {", "client_ploss":"} client.socket.ploss {", "client_requests":"} client.requests {", "client_retrans":"} client.socket.tcpi_delta_retrans {", "client_rtt":"} req.http.log-client:tcpi_rtt {", "fastly_is_edge":"} if(fastly.ff.visits_this_service == 0, "true", "false") {", "fastly_is_shield":"} if(req.http.log-origin:shield == server.datacenter, "true", "false") {", "fastly_pop":""} server.datacenter {"", "fastly_server":""} server.hostname {"", "fastly_shield_used":"} if(req.http.log-origin:shield, "%22" + req.http.log-origin:shield + "%22", "null") {", "origin_host":"} if(req.http.log-origin:host,"%22" + json.escape(req.http.log-origin:host) + "%22","null") {", "origin_ip":"} if(req.http.log-origin:ip,"%22" + json.escape(req.http.log-origin:ip) + "%22","null") {", "origin_method":"} if(req.http.log-origin:method,"%22" + json.escape(req.http.log-origin:method) + "%22","null") {", "origin_name":"} if(req.http.log-origin:name,"%22" + json.escape(req.http.log-origin:name) + "%22","null") {", "origin_port":"} if(req.http.log-origin:port,req.http.log-origin:port,"null") {", "origin_reason":"} if(req.http.log-origin:reason,"%22" + json.escape(req.http.log-origin:reason) + "%22","null") {", "origin_status":"} if(req.http.log-origin:status,json.escape(req.http.log-origin:status),"null") {", "origin_ttfb":"} if(req.http.log-origin:ttfb == "NaN", "null", req.http.log-origin:ttfb) {", "origin_ttlb":"} if(req.http.log-origin:ttlb == "NaN", "null", req.http.log-origin:ttlb) {", "origin_url":"} if(req.http.log-origin:url,"%22" + json.escape(req.http.log-origin:url) + "%22","null") {", "request_host":""} json.escape(req.http.log-request:host) {"", "request_is_h2":"} if(fastly_info.is_h2, "true", "false") {", "request_is_ipv6":"} if(req.is_ipv6, "true", "false") {", "request_method":""} json.escape(req.http.log-request:method) {"", "request_referer":"} if(req.http.referer, "%22" + json.escape(req.http.referer) + "%22", "null") {", "request_tls_version":"} if(tls.client.protocol, "%22" + tls.client.protocol + "%22", "null") {", "request_url":""} json.escape(req.http.log-request:url) {"", "request_user_agent":"} if(req.http.user-agent, "%22" + json.escape(req.http.user-agent) + "%22", "null") {", "response_age":"} regsub(obj.age, ".000$", "") {", "response_bytes_body":"} resp.body_bytes_written {", "response_bytes_header":"} resp.header_bytes_written {", "response_bytes":"} resp.bytes_written {", "response_cache_control":"} if(resp.http.cache-control, "%22" + json.escape(resp.http.cache-control) + "%22", "null") {", "response_completed":"} if(resp.completed, "true", "false") {", "response_content_length":"} if(resp.http.content-length, resp.http.content-length, "null") {", "response_content_type":"} if(resp.http.content-type, "%22" + json.escape(resp.http.content-type) + "%22", "null") {", "response_reason":"} if(resp.response,"%22" + json.escape(resp.response) + "%22","null") {", "response_state":""} fastly_info.state {"", "response_status":"} resp.status {", "response_ttfb":"} req.http.log-response:ttfb {", "response_ttl":"} obj.ttl {", "response_ttlb":"} req.http.log-response:ttlb " }";
}
}
